#include "tiny_rv.nh"
#include "fetch.nh"
#include "format.nh"
#include "integer_register.nh"
#include "integer_arithmetic_logic.nh"
#include "funct3.nh"
#include "csr.nh"

module tiny_rv
{
    fetch ifetch;
    //decode idecode;
    integer_register reg_file;
    integer_arithmetic_logic ialu;
    control_state_registers csr;

    reg current_pc[32];
    reg next_pc[32];
    reg fetch_0_addr[32];
    reg fetch_2_inst[32];
    proc_name fetch_0_stage(fetch_0_addr), fetch_1_stage();
    proc_name fetch_2_stage(fetch_2_inst);
    reg exec_inst[32], exec_pc[32];
    proc_name execute_stage(exec_inst, exec_pc);
    reg wb_rd[5], wb_value[32], wb_opcode[7] = 0;
    reg wb_src[5];
    reg wb_funct3[3];
    reg wb_rd_waiting[5];
    reg wb_value2[32];
    proc_name write_back_stage(wb_rd, wb_value, wb_opcode);
    proc_name write_back_stage_load(wb_rd, wb_value, wb_funct3);
    proc_name write_back_stage_load_waiting(wb_rd_waiting);
    proc_name write_back_stage_store(wb_value, wb_value2, wb_funct3);
    proc_name write_back_stage_store_waiting();
    reg wb_csr[12];
    reg wb_csr_funct[2];
    proc_name write_back_stage_csr(wb_csr, wb_value, wb_rd, wb_csr_funct);

    wire source_1[32];
    wire source_2[32];
    wire result[32];
    wire comp_result;

    op_imm_t wire op_imm;
    op_t wire op;
    jal_t wire jal;
    jalr_t wire jalr;
    branch_t wire branch;
    load_t wire load;
    store_t wire store;
    system_t wire system;

    // for hazard (bypass)
    wire rs1[5], rs1_value[32];
    wire rs2[5], rs2_value[32];
    func_self read_register_1(rs1) : rs1_value;
    func_self read_register_2(rs2) : rs2_value;

    func_self stall();
    func_self interlock();

    func start
    {
        fetch_0_stage(start_address);
    }

    func ifetch.request
    {
        request(ifetch.address);
    }

    func enable
    {
        ifetch.enable(instruction);
    }

    proc fetch_0_stage
    {
        next_pc := fetch_0_addr + 32'h4;

        if(!stall && !interlock)
        {
            ifetch.run(fetch_0_addr);
            fetch_1_stage();
            current_pc := fetch_0_addr;
        }
    }

    proc fetch_1_stage
    {
        if(ifetch.done)
        {
            if(!interlock)
            {
                //execute_stage(ifetch.inst_out, fetch_1_addr);
                execute_stage(ifetch.inst_out, current_pc);

                //XXX is not good
                fetch_0_stage(next_pc);
            }
            else
            {
                fetch_2_stage(ifetch.inst_out);
            }
        }
    }

    proc fetch_2_stage
    {
        if(!interlock)
        {
            execute_stage(fetch_2_inst, current_pc);
            fetch_0_stage(next_pc);
        }
    }

    func read_register_1
    {
        // 他のwb stageではstall or interlockしているので問題ない
        if((write_back_stage | write_back_stage_load_waiting | write_back_stage_csr) & rs1 == wb_rd)
        {
            return wb_value;
        }
        else {
            return reg_file.read_rs1(rs1);
        }
    }

    func read_register_2
    {
        // 他のwb stageではstall or interlockしているので問題ない
        if((write_back_stage | write_back_stage_load_waiting | write_back_stage_csr) & rs1 == wb_rd)
        {
            return wb_value;
        }
        else {
            return reg_file.read_rs2(rs2);
        }
    }

    proc execute_stage
    {
        if(!interlock)
        {
            any
            {
                exec_inst[6:0] == OP_IMM:
                {
                    op_imm = exec_inst;
                    source_1 = 32#op_imm.imm;
                    source_2 = read_register_1(op_imm.rs1);
                    result = ialu.calculate(
                            source_1, source_2,
                            op_imm.funct3, 1'b0);
                    write_back_stage(op_imm.rd, result, op_imm.opcode);
                }
                exec_inst[6:0] == OP:
                {
                    op = exec_inst;
                    source_1 = read_register_1(op.rs1);
                    source_2 = read_register_2(op.rs2);
                    result = ialu.calculate(
                            source_1, source_2,
                            op.funct3, op.funct7[5]);
                    write_back_stage(op.rd, result, op.opcode);
                }
                exec_inst[6:0] == JAL:
                {
                    stall();
                    jal = exec_inst;
                    source_1 = 32#{jal.imm0, jal.imm1, jal.imm2, jal.imm3, 1'b0};
                    source_2 = exec_pc;
                    result = ialu.calculate(source_1, source_2, FUNCT3_ADD_SUB, 0);
                    fetch_0_stage(result);
                    write_back_stage(jal.rd, exec_pc, jal.opcode);
                }
                exec_inst[6:0] == JALR:
                {
                    stall();
                    jalr = exec_inst;
                    source_1 = read_register_1(jalr.rs1);
                    source_2 = 32#jalr.imm;
                    result = ialu.calculate(source_1, source_2, jalr.funct3, 0);
                    fetch_0_stage(result);
                    write_back_stage(jalr.rd, exec_pc, jalr.opcode);
                }
                exec_inst[6:0] == BRANCH:
                {
                    branch = exec_inst;
                    source_1 = read_register_1(branch.rs1);
                    source_2 = read_register_2(branch.rs2);
                    comp_result = ialu.compare(source_1, source_1, branch.funct3);
                    result = ialu.calculate(
                                exec_pc,
                                32#{branch.imm12, branch.imm11, branch.imm10_5,
                                    branch.imm4_1, 1'b0},
                                FUNCT3_ADD_SUB,
                                1'b0);
                    if(comp_result)
                    {
                        stall();
                        fetch_0_stage(result);
                    }
                }
                exec_inst[6:0] == LOAD:
                {
                    load = exec_inst;
                    source_1 = read_register_1(load.rs1);
                    source_2 = 32#{load.imm};
                    result = ialu.calculate(source_1, source_2,
                                FUNCT3_ADD_SUB, 1'b0);
                    write_back_stage_load(load.rd, result, load.funct3);
                }
                exec_inst[6:0] == STORE:
                {
                    store = exec_inst;
                    source_1 = read_register_1(store.rs1);
                    source_2 = 32#{store.offset_11_5, store.offset_4_0};
                    result = ialu.calculate(source_1, source_2, FUNCT3_ADD_SUB, 1'b0);
                    write_back_stage_store(result, read_register_2(store.rs2), store.width);
                }
                exec_inst[6:0] == SYSTEM:
                {
                    system = exec_inst;
                    if(system.is_imm)
                    {
                        source_1 = read_register_1(system.rs1);
                    }
                    else
                    {
                        source_1 = 32#{system.rs1};
                    }
                    write_back_stage_csr(system.csr, source_1, system.rd, system.funct);
                }
                //TODO add behavior of other opcodes
                else:
                {
                    error(8'h0);
                }
            }
            finish();
        }
    }

    proc write_back_stage
    {
        any
        {
            wb_opcode == JAL || wb_opcode == JALR:
            {
                reg_file.write(wb_rd, wb_value);
            }
            wb_opcode == OP_IMM || wb_opcode == OP:
            {
                reg_file.write(wb_rd, wb_value);
            }
            else:
            {
                error(8'h1);
            }
        }
        finish();
    }

    proc write_back_stage_load
    {
        interlock();
        any
        {
            wb_funct3 == WIDTH_W:
            {
                load_w(wb_value);
                write_back_stage_load_waiting(wb_rd);
            }
            else:
            {
                error(8'h2);
            }
        }
    }

    proc write_back_stage_load_waiting
    {
        if(load_done)
        {
            reg_file.write(wb_rd_waiting, load_data);
            finish();
        }
        else
        {
            interlock();
        }
    }

    proc write_back_stage_store
    {
        interlock();
        any
        {
            wb_funct3 == WIDTH_B:
            {
                store_b(wb_value, 32#{wb_value2[7:0]});
                write_back_stage_store_waiting();
            }
            else:
            {
                error(8'h3);
            }
        }
    }

    proc write_back_stage_store_waiting
    {
        interlock();
        if(store_done)
        {
            finish();
        }
    }

    //proc_name write_back_stage_csr(wb_csr, wb_value, wb_rd, wb_csr_funct);
    proc write_back_stage_csr
    {
        wire csr_result[32];
        any
        {
            wb_csr_funct == CSR_FUNCT_RS:
            {
                csr_result = csr.read_write(wb_csr, wb_value);
                reg_file.write(wb_rd, csr_result);
                finish();
            }
            else:
            {
                error(8'h4);
            }
        }
    }

#ifdef DEBUG
    func register_dump
    {
        reg_file.dump();
    }

    func reg_file.dump_done
    {
        register_dump_done();
    }
#endif
}
