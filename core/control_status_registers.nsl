#include "control_status_registers.nh"

// funct for csr
#define CSR_FUNCT_RW    (2'b01)
#define CSR_FUNCT_RS    (2'b10)
#define CSR_FUNCT_RC    (2'b11)
#define CSR_FUNCT_PREV  (2'b00)


#define CSR_MHARTID (12'hf14)

#define CSR_MSTATUS (12'h300)
//#define CSR_MISA    (12'h301)
#define CSR_MTVEC   (12'h305)
#define CSR_MEPC    (12'h341)

// mcause exception codes
#define MCAUSE_EC_ECALL_M_MODE  (32'd11)
#define MCAUSE_EC_ILLEGAL_INST  (32'd2)

struct mstatus_t
{
    sd;
    reserved1[8];
    tsr;
    tw;
    tvm;
    mxr;
    sum;
    mprev;
    xs[2];
    fs[2];
    mpp[2];
    reserved2[2];
    spp;
    mpie;
    reserved3;
    spie;
    upie;
    mie;
    reserved4;
    sie;
    uie;
};

module control_status_registers
{
    mstatus_t reg mstatus = 0;
    reg mhartid[32] = 0 ;
    reg mepc[32] = 0;
    reg mtvec[32] = 0;
    reg mcause[32] = 0;

    wire update_funct[2], update_value[32],
         update_source[32], update_result[32];

    func_self update(update_funct, update_value, update_source)
        : update_result;

    func update
    {
        any
        {
            update_funct == CSR_FUNCT_RS:
            {
                return update_value | update_source;
            }
            update_funct == CSR_FUNCT_RW:
            {
                return update_source;
            }
            else:
            {
                error(ERROR_CSR_UNKNWON_FUNCT);
            }
        }
    }

    func read_update
    {
        if(address[9:8] != 2'b11)
        {
            trap(mtvec & 0xfffffffc);
            mcause := MCAUSE_EC_ILLEGAL_INST;
        }
        else if(funct == CSR_FUNCT_PREV)
        {
            any
            {
                address == 12'h302:
                {
                    trap(mepc);
                }
                else:
                {
                    error(ERROR_CSR_UNKNWON_ADDR);
                }
            }
        }
        else
        {
            any
            {
                address == CSR_MHARTID:
                {
                    mhartid := update(funct, mhartid, source);
                    return mhartid;
                }
                address == CSR_MTVEC:
                {
                    mtvec := update(funct, mtvec, source);
                    return mtvec;
                }
                address == CSR_MSTATUS:
                {
                    //TODO
                    mstatus := update(funct, mstatus, source);
                    return mstatus;
                }
                address == CSR_MEPC:
                {
                    mepc := update(funct, mepc, source);
                    return mepc;
                }
                //Machine Protection and Translation
                address >= 12'h3a0 && address <= 12'h3bf:
                {
                    trap(mtvec & 0xfffffffc);
                    mcause := MCAUSE_EC_ILLEGAL_INST;
                }
                address >= 12'h302 && address <= 12'h304:
                {
                    trap(mtvec & 0xfffffffc);
                    mcause := MCAUSE_EC_ILLEGAL_INST;
                }
                else:
                {
                    error(ERROR_CSR_UNKNWON_ADDR);
                }
            }
        }
    }
}
