#include "arbiter.nh"

#define REQUEST_WAIT_NOTHING        (7'b0000000)
#define REQUEST_WAIT_INSTRUCTION    (7'b0000001)
#define REQUEST_WAIT_LOAD_W         (7'b0000010)
#define REQUEST_WAIT_LOAD_H         (7'b0000100)
#define REQUEST_WAIT_LOAD_B         (7'b0001000)
#define REQUEST_WAIT_STORE_W        (7'b0010000)
#define REQUEST_WAIT_STORE_H        (7'b0100000)
#define REQUEST_WAIT_STORE_B        (7'b1000000)

module arbiter
{
    axi4_lite_master master;

    reg number_of_store_byte[2], write_address[32], write_data[32];
    proc_name idle, req_inst;
    proc_name req_load_store(number_of_store_byte, write_address, write_data);
    reg wait_request[7] = 0; //REQUEST_WAIT_NOTHING;
    reg requested_address[32] = 0;
    reg requested_data[32] = 0;
    wire load_or_store;

    wire next_request[7];
    func_self get_next_request() : next_request;

    wire request_addr[32], request_data[32];

    state_name reseted, running;

    load_or_store = load_w || load_h || load_b || store_w || store_h || store_b;

    func get_next_request
    {
        any
        {
            load_w:
            {
                return REQUEST_WAIT_LOAD_W;
            }
            load_h:
            {
                return REQUEST_WAIT_LOAD_H;
            }
            load_b:
            {
                return REQUEST_WAIT_LOAD_B;
            }
            store_w:
            {
                return REQUEST_WAIT_STORE_W;
            }
            store_h:
            {
                return REQUEST_WAIT_STORE_H;
            }
            store_b:
            {
                return REQUEST_WAIT_STORE_B;
            }
        }
    }

    state reseted
    {
        idle();
        goto running;
    }

    state running {}

    proc idle
    {
        if(request_inst)
        {
            req_inst();
            master.read_value(i_address);
            if(load_or_store)
            {
                requested_address := d_address;
                requested_data := d_in_data;
                wait_request := get_next_request();
            }
        }
        else if(load_or_store)
        {
            //TODO
            req_load_store(2'b00, 32'h0, 32'h0);
            error(ERROR_DUMMY_ARBITER);
        }
    }

    proc req_inst
    {
        if(master.data_arrive)
        {
            inst_done(master.output_value);
            wait_request := REQUEST_WAIT_NOTHING;
            if(wait_request != 7'h00)
            {
                request_addr = requested_address;
                request_data = requested_data;
            }
            else
            {
                request_addr = d_address;
                request_data = d_in_data;
            }

            any
            {
                load_w || load_h || load_b
                    || wait_request == REQUEST_WAIT_LOAD_W
                    || wait_request == REQUEST_WAIT_LOAD_H
                    || wait_request == REQUEST_WAIT_LOAD_B:
                {
                    req_load_store(2'b00, 32'h0, 32'h0);
                    master.read_value(request_addr);
                }
                store_b || wait_request == REQUEST_WAIT_STORE_B:
                {
                    req_load_store(2'b00, 32'h0, 32'h0);
                    master.write_value(request_addr, {24'h0, request_data[7:0]});
                }
                store_h || wait_request == REQUEST_WAIT_STORE_H:
                {
                    master.write_value(request_addr, {24'h0, request_data[7:0]});
                    req_load_store(
                            2'b01,
                            request_addr + 32'h1,
                            {8'h0, request_data[31:8]});
                }
                store_w || wait_request == REQUEST_WAIT_STORE_W:
                {
                    master.write_value(request_addr, {24'h0, request_data[7:0]});
                    req_load_store(
                            2'b11,
                            request_addr + 32'h1,
                            {8'h0, request_data[31:8]});
                }
                else:
                {
                    idle();
                }
            }
        }
    }

    proc req_load_store
    {

        if(master.data_arrive)
        {
            load_done(master.output_value);
        }
        if((number_of_store_byte == 2'b00) & master.write_done)
        {
            store_done();
        }

        if(master.data_arrive ||
                ((number_of_store_byte == 2'b00) & master.write_done))
        {
            if(request_inst)
            {
                req_inst();
                master.read_value(i_address);
            }
            else if(wait_request == REQUEST_WAIT_INSTRUCTION)
            {
                wait_request := REQUEST_WAIT_NOTHING;
                req_inst();
                master.read_value(requested_address);
            }
            else
            {
                idle();
            }
        }
        else if(request_inst)
        {
            wait_request := REQUEST_WAIT_INSTRUCTION;
            requested_address := i_address;
        }

        if(number_of_store_byte != 2'b00)
        {
            if(master.write_done)
            {
                master.write_value(write_address, {24'h0, write_data[7:0]});
                req_load_store(
                        number_of_store_byte - 2'b01,
                        write_address + 32'h1,
                        {8'h0, write_data[31:8]});
            }
        }
    }

    /*
     * connection for axi master
     */
    awvalid = master.awvalid;
    master.awready = awready;
    awaddr = master.awaddr;
    awprot = master.awprot;
    wvalid = master.wvalid;
    master.wready = wready;
    wdata = master.wdata;
    wstrb = master.wstrb;
    master.bvalid = bvalid;
    bready = master.bready;
    master.bresp = bresp;
    arvalid = master.arvalid;
    master.arready = arready;
    araddr = master.araddr;
    arprot = master.arprot;
    master.rvalid = rvalid;
    rready = master.rready;
    master.rdata = rdata;
    master.rresp = rresp;
}
