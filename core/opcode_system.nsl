#include "opcode_system.nh"

#define SYSTEM_FUNCT_CONTROL    (2'b00)
#define SYSTEM_FUNCT_CSR_RW     (2'b01)
#define SYSTEM_FUNCT_CSR_RS     (2'b10)
#define SYSTEM_FUNCT_CSR_RC     (2'b11)

#define CSR_MHARTID (12'hf14)
#define CSR_MTVEC   (12'h305)
#define CSR_MSTATUS (12'h300)
#define CSR_MEPC    (12'h341)

#define SYSTEM_INT_MRET (12'h302)

declare control_status_registers
{
    output error_num[ERROR_NUM_BIT_WIDTH];

    input address[12];
    input source[32];
    input funct[2];
    output result[32];
    output trap_address[32];

    func_in read_update(address, funct, source): result;
    func_out trap(trap_address);

    func_out error(error_num);
}

module control_status_registers
{
    reg mhartid[32] = 0;
    reg mtvec[32] = 0;
    reg mstatus[32] = 0;
    reg mepc[32] = 0;

    wire update_funct[2], update_value[32],
         update_source[32], update_result[32];
    func_self update(update_funct, update_value, update_source): update_result;

    func update
    {
        any
        {
            update_funct == SYSTEM_FUNCT_CSR_RS:
            {
                return update_value | update_source;
            }
            update_funct == SYSTEM_FUNCT_CSR_RW:
            {
                return update_source;
            }
            else:
            {
                error(ERROR_CSR_UNKNWON_FUNCT);
            }
        }
    }

    func read_update
    {
        any
        {
            address == CSR_MHARTID:
            {
                mhartid := update(funct, mhartid, source);
                return mhartid;
            }
            address == CSR_MTVEC:
            {
                mtvec := update(funct, mtvec, source);
                return mtvec;
            }
            address == CSR_MSTATUS:
            {
                mstatus := update(funct, mstatus, source);
                return mstatus;
            }
            address == CSR_MEPC:
            {
                mepc := update(funct, mepc, source);
                return mepc;
            }
            //pmpaddr
            address >= 12'h3a0 && address <= 12'h3bf:
            {
                trap(mtvec);
                return 0;
            }
            //delegation
            address == 12'h302 || address == 12'h180 || address == 12'h303:
            {
                trap(mtvec);
                return 0;
            }
            else:
            {
                error(ERROR_NOT_IMPLEMENTED);
            }
        }
    }
}

module opcode_system
{
    control_status_registers csr;

    //func_in execute(address, funct, source) : result;
    func execute
    {
        any
        {
            funct == SYSTEM_FUNCT_CONTROL:
            {
                any
                {
                    address == SYSTEM_INT_MRET:
                    {
                        trap(csr.read_update(CSR_MEPC, SYSTEM_FUNCT_CSR_RS, 0));
                    }
                    else:
                    {
                        error(ERROR_NOT_IMPLEMENTED);
                    }

                }
            }
            else:
            {
                return csr.read_update(address, funct, source);
            }
        }
    }

    func csr.trap
    {
        trap(csr.trap_address);
    }

    func csr.error
    {
        error(csr.error_num);
    }
}
