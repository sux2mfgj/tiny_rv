#include "tiny_rv.nh"
#include "fetch.nh"
#include "format.nh"
#include "integer_register.nh"
#include "integer_arithmetic_logic.nh"

module tiny_rv
{
    reg pc[32];
    fetch ifetch;
    //decode idecode;
    integer_register reg_file;
    integer_arithmetic_logic ialu;

    proc_name fetch_0_stage, fetch_1_stage;
    reg exec_inst[32];
    proc_name execute_stage(exec_inst);
    reg wb_rd[5], wb_value[32];
    proc_name write_back_stage(wb_rd, wb_value);

    wire source_1[32];
    wire source_2[32];
    wire result[32];

    op_imm_t wire op_imm;
    op_t wire op;
    jal_t wire jal;

    func start
    {
        //pc := 32'0h00001000;
        pc := 32'0h00000000;
        fetch_0_stage();
    }

    func ifetch.request
    {
        request(ifetch.address);
    }

    func enable
    {
        ifetch.enable(instruction);
    }

    proc fetch_0_stage
    {
        pc := pc + 32'0h4;
        ifetch.run(pc);
        if(ifetch.done)
        {
            execute_stage(ifetch.inst_out);
            fetch_0_stage();
        }
        else
        {
            fetch_1_stage();
        }
    }

    proc fetch_1_stage
    {
        if(ifetch.done)
        {
            execute_stage(ifetch.inst_out);
            fetch_0_stage();
        }
    }

    proc execute_stage
    {
        any
        {
            exec_inst[6:0] == OP_IMM:
            {
                op_imm = exec_inst;
                source_1 = 32#op_imm.imm;
                //TODO: you have to check data hazard
                //when rs1 is equal to wb_rd, the value have to be bypassed.
                source_2 = reg_file.read_rs1(op_imm.rs1);
                result = ialu.calculate(
                        source_1, source_2,
                        op_imm.funct3, 0);
                write_back_stage(op_imm.rd, result);
            }
            exec_inst[6:0] == OP:
            {
                op = exec_inst;
                //TODO: you have to check data hazard
                //when rs1 or rs2 is equal to wb_rd,
                //          the value have to be bypassed.
                source_1 = reg_file.read_rs1(op.rs1);
                source_2 = reg_file.read_rs2(op.rs2);
                result = ialu.calculate(
                        source_1, source_2,
                        op.funct3, op.funct7[5]);
                write_back_stage(op.rd, result);
            }
            exec_inst[6:0] == JAL:
            {
                jal = exec_inst;
                source_1 = 32#{jal.imm0, jal.imm1, jal.imm2, jal.imm3};
                source_2 = ex_pc;
                //WIP
            }
            //TODO add behavior of other opcodes
            else:
            {
                error();
            }
        }
        finish();
    }

    proc write_back_stage
    {
        reg_file.write(wb_rd, wb_value);
        finish();
    }
}
